/* tslint:disable */
/* eslint-disable */
/**
 * NexusRAG API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  ApiKeyCreateRequest,
  ErrorEnvelope,
  NexusragAppsApiResponseSuccessEnvelopeUsageSummaryResponse2,
  PlanUpgradeRequestPayload,
  SuccessEnvelopeApiKeyCreateResponse,
  SuccessEnvelopeApiKeyListResponse,
  SuccessEnvelopeApiKeyResponse,
  SuccessEnvelopeBillingWebhookTestResponse,
  SuccessEnvelopePlanResponse,
  SuccessEnvelopePlanUpgradeResponse,
  SuccessEnvelopeUsageTimeseriesResponse,
} from '../models/index';
import {
    ApiKeyCreateRequestFromJSON,
    ApiKeyCreateRequestToJSON,
    ErrorEnvelopeFromJSON,
    ErrorEnvelopeToJSON,
    NexusragAppsApiResponseSuccessEnvelopeUsageSummaryResponse2FromJSON,
    NexusragAppsApiResponseSuccessEnvelopeUsageSummaryResponse2ToJSON,
    PlanUpgradeRequestPayloadFromJSON,
    PlanUpgradeRequestPayloadToJSON,
    SuccessEnvelopeApiKeyCreateResponseFromJSON,
    SuccessEnvelopeApiKeyCreateResponseToJSON,
    SuccessEnvelopeApiKeyListResponseFromJSON,
    SuccessEnvelopeApiKeyListResponseToJSON,
    SuccessEnvelopeApiKeyResponseFromJSON,
    SuccessEnvelopeApiKeyResponseToJSON,
    SuccessEnvelopeBillingWebhookTestResponseFromJSON,
    SuccessEnvelopeBillingWebhookTestResponseToJSON,
    SuccessEnvelopePlanResponseFromJSON,
    SuccessEnvelopePlanResponseToJSON,
    SuccessEnvelopePlanUpgradeResponseFromJSON,
    SuccessEnvelopePlanUpgradeResponseToJSON,
    SuccessEnvelopeUsageTimeseriesResponseFromJSON,
    SuccessEnvelopeUsageTimeseriesResponseToJSON,
} from '../models/index';

export interface CreateApiKeyV1SelfServeApiKeysPostRequest {
    apiKeyCreateRequest: ApiKeyCreateRequest;
    idempotencyKey?: string | null;
}

export interface RevokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRequest {
    keyId: string;
    idempotencyKey?: string | null;
}

export interface UpgradePlanRequestV1SelfServePlanUpgradeRequestPostRequest {
    planUpgradeRequestPayload: PlanUpgradeRequestPayload;
    idempotencyKey?: string | null;
}

export interface UsageSummaryV1SelfServeUsageSummaryGetRequest {
    windowDays?: number;
}

export interface UsageTimeseriesV1SelfServeUsageTimeseriesGetRequest {
    metric?: string;
    granularity?: string;
    days?: number;
}

/**
 * 
 */
export class SelfServeApi extends runtime.BaseAPI {

    /**
     * Creates request options for billingWebhookTestV1SelfServeBillingWebhookTestPost without sending the request
     */
    async billingWebhookTestV1SelfServeBillingWebhookTestPostRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/billing/webhook-test`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Billing Webhook Test
     */
    async billingWebhookTestV1SelfServeBillingWebhookTestPostRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopeBillingWebhookTestResponse>> {
        const requestOptions = await this.billingWebhookTestV1SelfServeBillingWebhookTestPostRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopeBillingWebhookTestResponseFromJSON(jsonValue));
    }

    /**
     * Billing Webhook Test
     */
    async billingWebhookTestV1SelfServeBillingWebhookTestPost(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopeBillingWebhookTestResponse> {
        const response = await this.billingWebhookTestV1SelfServeBillingWebhookTestPostRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for createApiKeyV1SelfServeApiKeysPost without sending the request
     */
    async createApiKeyV1SelfServeApiKeysPostRequestOpts(requestParameters: CreateApiKeyV1SelfServeApiKeysPostRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['apiKeyCreateRequest'] == null) {
            throw new runtime.RequiredError(
                'apiKeyCreateRequest',
                'Required parameter "apiKeyCreateRequest" was null or undefined when calling createApiKeyV1SelfServeApiKeysPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['idempotencyKey'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['idempotencyKey']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/api-keys`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ApiKeyCreateRequestToJSON(requestParameters['apiKeyCreateRequest']),
        };
    }

    /**
     * Create Api Key
     */
    async createApiKeyV1SelfServeApiKeysPostRaw(requestParameters: CreateApiKeyV1SelfServeApiKeysPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopeApiKeyCreateResponse>> {
        const requestOptions = await this.createApiKeyV1SelfServeApiKeysPostRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopeApiKeyCreateResponseFromJSON(jsonValue));
    }

    /**
     * Create Api Key
     */
    async createApiKeyV1SelfServeApiKeysPost(requestParameters: CreateApiKeyV1SelfServeApiKeysPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopeApiKeyCreateResponse> {
        const response = await this.createApiKeyV1SelfServeApiKeysPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for getSelfServePlanV1SelfServePlanGet without sending the request
     */
    async getSelfServePlanV1SelfServePlanGetRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/plan`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Get Self Serve Plan
     */
    async getSelfServePlanV1SelfServePlanGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopePlanResponse>> {
        const requestOptions = await this.getSelfServePlanV1SelfServePlanGetRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopePlanResponseFromJSON(jsonValue));
    }

    /**
     * Get Self Serve Plan
     */
    async getSelfServePlanV1SelfServePlanGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopePlanResponse> {
        const response = await this.getSelfServePlanV1SelfServePlanGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for listApiKeysV1SelfServeApiKeysGet without sending the request
     */
    async listApiKeysV1SelfServeApiKeysGetRequestOpts(): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/api-keys`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * List Api Keys
     */
    async listApiKeysV1SelfServeApiKeysGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopeApiKeyListResponse>> {
        const requestOptions = await this.listApiKeysV1SelfServeApiKeysGetRequestOpts();
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopeApiKeyListResponseFromJSON(jsonValue));
    }

    /**
     * List Api Keys
     */
    async listApiKeysV1SelfServeApiKeysGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopeApiKeyListResponse> {
        const response = await this.listApiKeysV1SelfServeApiKeysGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for revokeApiKeyV1SelfServeApiKeysKeyIdRevokePost without sending the request
     */
    async revokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRequestOpts(requestParameters: RevokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['keyId'] == null) {
            throw new runtime.RequiredError(
                'keyId',
                'Required parameter "keyId" was null or undefined when calling revokeApiKeyV1SelfServeApiKeysKeyIdRevokePost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (requestParameters['idempotencyKey'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['idempotencyKey']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/api-keys/{key_id}/revoke`;
        urlPath = urlPath.replace(`{${"key_id"}}`, encodeURIComponent(String(requestParameters['keyId'])));

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Revoke Api Key
     */
    async revokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRaw(requestParameters: RevokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopeApiKeyResponse>> {
        const requestOptions = await this.revokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopeApiKeyResponseFromJSON(jsonValue));
    }

    /**
     * Revoke Api Key
     */
    async revokeApiKeyV1SelfServeApiKeysKeyIdRevokePost(requestParameters: RevokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopeApiKeyResponse> {
        const response = await this.revokeApiKeyV1SelfServeApiKeysKeyIdRevokePostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for upgradePlanRequestV1SelfServePlanUpgradeRequestPost without sending the request
     */
    async upgradePlanRequestV1SelfServePlanUpgradeRequestPostRequestOpts(requestParameters: UpgradePlanRequestV1SelfServePlanUpgradeRequestPostRequest): Promise<runtime.RequestOpts> {
        if (requestParameters['planUpgradeRequestPayload'] == null) {
            throw new runtime.RequiredError(
                'planUpgradeRequestPayload',
                'Required parameter "planUpgradeRequestPayload" was null or undefined when calling upgradePlanRequestV1SelfServePlanUpgradeRequestPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (requestParameters['idempotencyKey'] != null) {
            headerParameters['Idempotency-Key'] = String(requestParameters['idempotencyKey']);
        }

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/plan/upgrade-request`;

        return {
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlanUpgradeRequestPayloadToJSON(requestParameters['planUpgradeRequestPayload']),
        };
    }

    /**
     * Upgrade Plan Request
     */
    async upgradePlanRequestV1SelfServePlanUpgradeRequestPostRaw(requestParameters: UpgradePlanRequestV1SelfServePlanUpgradeRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopePlanUpgradeResponse>> {
        const requestOptions = await this.upgradePlanRequestV1SelfServePlanUpgradeRequestPostRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopePlanUpgradeResponseFromJSON(jsonValue));
    }

    /**
     * Upgrade Plan Request
     */
    async upgradePlanRequestV1SelfServePlanUpgradeRequestPost(requestParameters: UpgradePlanRequestV1SelfServePlanUpgradeRequestPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopePlanUpgradeResponse> {
        const response = await this.upgradePlanRequestV1SelfServePlanUpgradeRequestPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for usageSummaryV1SelfServeUsageSummaryGet without sending the request
     */
    async usageSummaryV1SelfServeUsageSummaryGetRequestOpts(requestParameters: UsageSummaryV1SelfServeUsageSummaryGetRequest): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        if (requestParameters['windowDays'] != null) {
            queryParameters['window_days'] = requestParameters['windowDays'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/usage/summary`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Usage Summary
     */
    async usageSummaryV1SelfServeUsageSummaryGetRaw(requestParameters: UsageSummaryV1SelfServeUsageSummaryGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<NexusragAppsApiResponseSuccessEnvelopeUsageSummaryResponse2>> {
        const requestOptions = await this.usageSummaryV1SelfServeUsageSummaryGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => NexusragAppsApiResponseSuccessEnvelopeUsageSummaryResponse2FromJSON(jsonValue));
    }

    /**
     * Usage Summary
     */
    async usageSummaryV1SelfServeUsageSummaryGet(requestParameters: UsageSummaryV1SelfServeUsageSummaryGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<NexusragAppsApiResponseSuccessEnvelopeUsageSummaryResponse2> {
        const response = await this.usageSummaryV1SelfServeUsageSummaryGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates request options for usageTimeseriesV1SelfServeUsageTimeseriesGet without sending the request
     */
    async usageTimeseriesV1SelfServeUsageTimeseriesGetRequestOpts(requestParameters: UsageTimeseriesV1SelfServeUsageTimeseriesGetRequest): Promise<runtime.RequestOpts> {
        const queryParameters: any = {};

        if (requestParameters['metric'] != null) {
            queryParameters['metric'] = requestParameters['metric'];
        }

        if (requestParameters['granularity'] != null) {
            queryParameters['granularity'] = requestParameters['granularity'];
        }

        if (requestParameters['days'] != null) {
            queryParameters['days'] = requestParameters['days'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/v1/self-serve/usage/timeseries`;

        return {
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        };
    }

    /**
     * Usage Timeseries
     */
    async usageTimeseriesV1SelfServeUsageTimeseriesGetRaw(requestParameters: UsageTimeseriesV1SelfServeUsageTimeseriesGetRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SuccessEnvelopeUsageTimeseriesResponse>> {
        const requestOptions = await this.usageTimeseriesV1SelfServeUsageTimeseriesGetRequestOpts(requestParameters);
        const response = await this.request(requestOptions, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SuccessEnvelopeUsageTimeseriesResponseFromJSON(jsonValue));
    }

    /**
     * Usage Timeseries
     */
    async usageTimeseriesV1SelfServeUsageTimeseriesGet(requestParameters: UsageTimeseriesV1SelfServeUsageTimeseriesGetRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SuccessEnvelopeUsageTimeseriesResponse> {
        const response = await this.usageTimeseriesV1SelfServeUsageTimeseriesGetRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
